# 性能优化

### 1. UI优化
**UITableViewCell优化**
1. 缓存行高，提前计算并缓存好高度，因为heightForRow最频繁的调用。
2. 异步绘制，遇到复杂界面，性能瓶颈时，可能是突破口。
3. 滑动时按需加载，这个在大量图片展示，网络加载时，很管用。（SDWebImage已经实现异步加载）。
4. 重用cells。
5. 如果cell内显示得内容来自web，使用异步加载，缓存结果请求。
6. 少用或不用透明图层，使用不透明视图。
7. 尽量使所有的view opaque，包括cell本身。
8. 减少subViews
9. 少用addView给cell动态添加view，可以初始化的时候就添加，然后通过hide控制是否显示。

**界面卡顿优化**
> 由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因

1. CPU 资源消耗原因和解决方案
对象创建
对象调整
对象销毁
布局计算
Autolayout
文本计算
文本渲染
图片的解码
图像的绘制

2. GPU 资源消耗原因和解决方案
纹理的渲染
视图的混合 (Composing)
图形的生成

[iOS 保持界面流畅的技巧](https://juejin.im/entry/564c31c860b2260e5bb03d12)

**UI卡顿检测**
检测方案一：基于Runloop
主线程绝大部分计算或者绘制任务都是以Runloop为单位发生。单次Runloop如果时长超过16ms，就会导致UI体验的卡顿。看起来kCFRunLoopExit的时间，减去kCFRunLoopEntry的时间，即为一次Runloop所耗费的时间，这样就能找出大于16ms的runloop。
> 方案一是可以通过监测runloop计算每次主线程的任务执行时间是否超过16ms来判断是否有卡顿，但是缺点在于无法定位卡顿的位置，所以有了方案二。

检测方案二：基于线程
检测方案三：CADisplayLink监控
CADisplayLink监控的思路是每个屏幕刷新周期，派发标记位设置任务到主线程中，如果多次超出16.7ms的刷新阙值，即可看作是发生了卡顿。

[iOS性能优化-UI卡顿检测](https://blog.csdn.net/u010262501/article/details/79616963)

### 2. 内存优化
原则:
1. 减少内存泄露 
2. 降低内存使用峰值 ([聊聊NSCache](https://www.jianshu.com/p/e850f8d120b0))
* lazy load, 懒加载
* 灵活运用图片和文件加载
* 拉长文件处理机制,逐步处理文件
* 处理内存警告
* 少用xib或Storyboard
3. 减少内存异常引用

[iOS 25个性能优化/内存优化常用方法](https://blog.csdn.net/majiakun1/article/details/79228665)

### 3. 启动优化 
应用的启动可分为pre-main阶段和main()阶段:
![启动过程](https://upload-images.jianshu.io/upload_images/1893416-d932008ce3c34620.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**pre-main阶段**
dyld的加载主要分为4步：
1. **Load dylibs**
* 尽量不使用内嵌（embedded）的dylib，加载内嵌dylib性能开销较大
* 合并已有的dylib和使用静态库（static archives），减少dylib的使用个数
* 懒加载dylib，但是要注意dlopen()可能造成一些问题，且实际上懒加载做的工作会更多
2. **Rebase/Bind**
* 减少ObjC类（class）、方法（selector）、分类（category）的数量
* 减少[C++虚函数](https://link.jianshu.com/?t=https%3A%2F%2Fblog.csdn.net%2Fu011702002%2Farticle%2Fdetails%2F77434297)的的数量（创建虚函数表有开销）
* 使用Swift structs（内部做了优化，符号数量更少）
3. **Objc setup**
大部分ObjC初始化工作已经在Rebase/Bind阶段做完了，这一步dyld会注册所有声明过的ObjC类，将分类插入到类的方法列表里，再检查每个selector的唯一性。
在这一步倒没什么优化可做的，Rebase/Bind阶段优化好了，这一步的耗时也会减少。
4. **Initializers**
* 少在类的`+load`方法里做事情，尽量把这些事情推迟到`+initiailize`
* 减少构造器函数个数，在构造器函数里少做些事情
* 减少C++静态全局变量的个数

**main()阶段**
1. 梳理各个二方/三方库，找到可以延迟加载的库，做延迟加载处理，比如放到首页控制器的viewDidAppear方法里。
2. 梳理业务逻辑，把可以延迟执行的逻辑，做延迟执行处理。比如检查新版本、注册推送通知等逻辑。
3. 避免复杂/多余的计算。
4. 采用性能更好的API。
5. 避免在首页控制器的viewDidLoad和viewWillAppear做太多事情，这2个方法执行完，首页控制器才能显示，部分可以延迟创建的视图应做延迟创建/懒加载处理。
6. 首页控制器用纯代码方式来构建。


**[启动耗时的测量](https://www.jianshu.com/p/5d4fcc5b534d)**
![pre-main阶段](https://upload-images.jianshu.io/upload_images/1893416-af2e421a060b79ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

[iOS深思篇 | 启动时间的度量和优化](https://www.jianshu.com/p/67f4c5b7ffcc)

### 4. 安装包体量优化
![安装包瘦身](https://upload-images.jianshu.io/upload_images/1893416-f9f6d33b2c571c11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 4.1 一些App常见的减肥方法
1. 清理废弃的资源文件与代码
这个就不用多说了，随着“历史的沉淀”，会有大量的废弃业务的代码以及资源文件，它的清理也是充满了坑坑洼洼。
2. 去重
去重包括很多方面，包括重复代码类、重复资源文件，对于点评美团这种业务繁多的App，工程项目中图片数量达到几千张，业务部门之间互相copy图片的现象是很常见的，之前写过一个工具，可以脚本扫描工程中的重复图片和重复代码，图片遍历对比每个图片的MD5值；代码文件比较复杂，写了一个算法去查找相似度为100%的代码文件；
3. 采取.xcassets方式管理图片
.xcassets的好处有很多，其中一个就是App Slicing的功能，App Slicing大致就是App Store会根据不同的设备准备不同的安装包(App Variant)，每个安装包(App Variant)都只有相应尺寸的图片,比如 iPhone 6 去下载时，只会下载到 @2x 的图片的安装包(App Variant)。
参考：http://www.jianshu.com/p/1034748e3fef
4. 代码的复用
代码复用涉及的范围比较广，我们在具体做的时候，是针对我们自己的业务建立一个独立的pod，这个pod专门用来存放我们业务中的工具类、通用控件等通用逻辑，这个pod建立之后，我们经过不断的重构与整理，去除了不少代码。
5. 纯代码布局以及去xib
刚加入点评时，就已经开始禁止使用xib进行布局了，xib布局在累积到一定程度会比纯代码布局有明显的空间劣势。
6. 按需加载
苹果的按需加载给我们提供了一种思路，常用的主要功能用到的Local处理，不常用的非必需的可以进行Remote处理；
详细参考：[On-Demand-Resources-Guide](http://benbeng.leanote.com/post/On-Demand-Resources-Guide)
7. 图片的统一
将图片统一为png，这也是苹果推荐的。如果有条件，可以考虑webp格式。
8. 背景图清理
很多业务代码的在做背景效果时，喜欢用图片，例如UIButton的背景，其实我们可以用简单的编码就可以替代。
9. 动态库
动态库可以大幅降低可执行文件包大小。

#### 4.2 主流的瘦身方法
App的安装包主要是由`资源`和`可执行文件`组成的;
ipa文件构成

![ipa文件构成](https://github.com/binzi56/iOSSmallKnowledgePool/blob/master/整理的小知识点/resources/ipa文件构成.png)

ipa瘦身优化点

![ipa瘦身优化点](https://github.com/binzi56/iOSSmallKnowledgePool/blob/master/整理的小知识点/resources/ipa瘦身优化点.png)

**App Thinning**
苹果提供的[App Thinning](https://help.apple.com/xcode/mac/current/#/devbbdc5ce4f)能根据用户特定设备和操作系统版本的功能量身定制应用程序交付，从而可以占用最小的空间。

App Thinning 有三种方式，包括:App Slicing、Bitcode、On-Demand Resources。
* `App Slicing`，会在你向 iTunes Connect 上传App后，对 App 做切割，创建不同的变体，这样就可以适用到不同的设备。
* `On-Demand Resources`，主要是为游戏多关卡场景服务的。它会根据用户的关卡进度下载随后几个关卡的资源，并且已经过关的资源也会被删掉，这样就可以减少初装App的包大小。
* `Bitcode`，是针对特定设备进行包大小优化，优化不明显。

实际使用:
大部分工作都是由`Xcode`和`App Store`来帮你完成的,你只需要`Xcode`添加`xcassets`目录，然后将图片
添加进来即可。

**无用图片资源**
1. 通过`find`命令获取App安装包中的所有资源文件，比如 find /Users/daiming/Project/ -name。
2. 设置用到的资源的类型，比如 jpg、gif、png、webp。
3. 使用正则匹配在源码中找出使用到的资源名，比如 pattern = @"@"(.+?)""。
4. 使用`find`命令找到的所有资源文件，再去掉代码中使用到的资源文件，剩下的就是无用资源了。

5. 对于按照规则设置的资源名，我们需要在匹配使用资源的正则表达式里添加相应的规则，比如 @“image_%d”。
6. 确认无用资源后，就可以对这些无用资源执行删除操作了。这个删除操作，你可以使用`NSFileManger`系统类提供的功能
来完成。

实际使用:

[LSUnusedResources](https://github.com/tinymind/LSUnusedResources)

![LSUnusedResources面板](https://github.com/binzi56/iOSSmallKnowledgePool/blob/master/整理的小知识点/resources/LSUnusedResources.png)

**图片资源压缩**
图片转成[WebP](https://developers.google.com/speed/webp/)
优势:
1. WebP压缩率高，而且肉眼看不出差异，同时支持有损和无损两种压缩模式。比如，将Gif 图转为Animated WebP ，有损压 缩模式下可减少 64%大小，无损压缩模式下可减少 19%大小。
2. WebP 支持 Alpha 透明和 24-bit 颜色数，不会像 PNG8 那样因为色彩不够而出现毛边。

实际使用:
压缩
* [Google_cwebp](https://developers.google.com/speed/webp/docs/precompiled)
* [Tencent_iSpart](http://isparta.github.io)

* [TinyPng](https://tinypng.com/)
* [ImageOptim](https://imageoptim.com/mac)

解析(显示)
* [libwebp解析范例](https://github.com/carsonmcdonald/WebP-iOS-example)

> 图片大小超过了100KB，你可以考虑使用 WebP;而小于100KB时，你可以使用网⻚工具 TinyPng或者 GUI工具ImageOptim进行图片压缩。

**代码瘦身**


[干货|今日头条iOS端安装包大小优化—思路与实践 ](https://www.jianshu.com/p/a3151dfebc9c)
[iOS APP安装包瘦身实践 ](https://www.jianshu.com/p/c94dedef90b7)
[iOS App Thinning 实践](https://www.jianshu.com/p/777567b85f63)

### 5. 网络请求优化
网络深度优化的点:
* NSCache缓存、Last-Modified、ETag
* 失败重发、缓存请求有网发送
* DNS解析
* 数据压缩：protobuf，WebP
* 弱网：2G、3G、4G、wifi下设置不同的超时时间
* TCP对头阻塞：GOOGLE提出QUIC协议，相当于在UDP协议之上再定义一套可靠传输协议

如果你已经使用 了 GET 请求，iOS 系统 SDK 已经帮你做好了缓存:
```
NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:4 * 1024 * 1024 diskCapacity:20 * 1024 * 1024 diskPath:nil];
[NSURLCache setSharedURLCache:urlCache];
```

[iOS网络深度优化总结 ](https://www.jianshu.com/p/a470ab485e39)
