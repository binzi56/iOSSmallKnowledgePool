# 常用第三方库篇
### `matrix-iOS`
卡顿的原因:
* 复杂 UI 、图文混排的绘制量过大;
* 在主线程上做网络同步请求;
* 在主线程做大量的IO 操作;
* 运算量过大，CPU持续高占用;
* 死锁和主子线程抢锁。

检测原理:

`Matrix` 卡顿监控在 `Runloop` 的起始最开始和结束最末尾位置添加 `Observer`，从而获得主线程的开始和结束状态。卡顿监控起一个子线程定时检查主线程的状态，当主线程的状态运行超过一定阈值则认为主线程卡顿，从而标记为一个卡顿。
主要有两点:
* 主程序 `Runloop` 超时的阈值是 `2` 秒，子线程的检查周期是 `1` 秒。每隔 `1` 秒，子线程检查主线程的运行状态;
* `CPU` 过高也可能导致应用出现卡顿,目前采用单核 `CPU` 的占用超过了 `80%`即认为当前`CPU` 占用就过高;
* 线程过多造成卡顿(>64)，不用记录主线程堆栈;

下面这四点是能够让卡顿监控系统在对 `App` 性能损耗很小的情况下，更好地监控到线上 `App` 卡顿情况的四个细节:
* 子线程监控检测时间间隔:监控卡顿的子线程是通过 `NSThread` 创建的，检测时间间隔正常情况是`1`秒，在出现 卡顿情况下，间隔时间会受检测线程退火算法影响，按照 **斐波那契数列** 递增，直到没有卡顿时恢复为`1`秒。
* 子线程监控退火算法:避免一个卡顿会写入多个文件的情况。
* `RunLoop` 卡顿时间阈值设置:对于 `RunLoop` 超时阈值的设置，我在第13篇文章里建议设置为3秒，微信设置的是2秒。
* `CPU` 使用率阈值设置:当单核 `CPU` 使用率超过 `80%`，就判定 `CPU` 占用过高。`CPU` 使用率过高，可能导致 `App` 卡顿。

退火算法:

为了降低检测带来的性能损耗，在检测线程增加了退火算法：
* 每次子线程检查到主线程卡顿，会先获得主线程的堆栈并保存到内存中（不会直接去获得线程快照保存到文件中）；
* 将获得的主线程堆栈与上次卡顿获得的主线程堆栈进行比对：
   * 如果堆栈不同，则获得当前的线程快照并写入文件中；
   * 如果相同则会跳过，并按照斐波那契数列将检查时间递增直到没有遇到卡顿或者主线程卡顿堆栈不一样。
