# 架构&框架&&需求
本篇打算总结架构&框架相关知识,有任何问题欢迎[issue](https://github.com/binzi56/iOSSmallKnowledgePool/issues);

### 构建底层的发布和订阅事件总线
由于 `Delegate` 和 `Block` 只适合做一对一数据传递，`KVO` 和 `NSNotificationCenter` 虽然可以支持一对多的数据传 递，但存在过于灵活而无法管控和维护的问题，而事件总线需要通过发布和订阅这种可管控方式实现一对一和一对多数据传 递。由此可以看出，iOS 现有的 `Delegate`、`Block`、`KVO`、`NSNotificationCenter` 等技术并不适合来做事件总线。

其实，响应式第三方库 `ReactiveCocoa` 和 `RxSwift` 对事件总线的支持是没有问题的，但这两个库更侧重的是响应式编程，事 件总线只是其中很小的一部分。

**`Promise`**
现在前端领域有一种模式叫作 `Promise`，这是一种专⻔针对异步数据操作编写的一套统一规则的模式。
本质上，这种模式本质是通过 `Promise` 对象**保存异步数据操作**，同时 `Promise` 对象提供统一的异步数据操作事件处理的**接 口**。这样，事件总线的数据订阅和数据发布事件，就可以通过 `Promise` 对象提供的接口实现出来，比以前通过`Delegate`回调 处理异步事件来说更加合理。

`Promise` 对象会有三种状态，分别是 `pending`、`fulfilled`、`rejected`:
* `pending` 表示 `Promise` 对象当前正在等待异步事件处理中;
* `fulfilled` 指的是 `Promise` 对象当前处理的异步事件已经成功完成;
* `rejected` 表示 `Promise` 对象当前处理的异步事件没有成功。

`Promise` 对象还有两个重要的方法，分别是 `then` 和 `catch`。`Promise` 对象每次执行完 `then` 和 `catch` 方法后，这两个方法会返回先前的 `Promise` 对象，同时根据异步操作结果改变`Promise` 对象的状态。

![](./resources/Promise方法.png)

有了 `Promise` 对象后，整个异步发布和订阅操作都以同步操作的方式表现出来了。`Promise` 对象不仅能够避免回调层层嵌套，而且通过 `Promise`的统一接口，使得事件总线的发布和订阅操作更加规范和易用。

**`PromiseKit`**
我们先来看看如何使用 `Promise` 对象的 `then` 和 `catch` 方法。
1. 假设有这么一个需求:
2. 首先，通过一个异步请求获取当前用户信息; 然后，根据获取到的用户信息里的用户编号再去异步请求获取用户的时间轴列表;
3. 最后，将用户的时间轴列表数据，赋值给当前类的时间轴列表属性。

```
firstly {
	// 异步获取当前用户信息
	fetchUserInfo()
}.then { userInfo in
	// 使用异步获取到的用户信息中的 uid 再去异步获取用户的 timeline
	fetchUserTimeline(uid: userInfo.uid)
}.then { timeline in
	// 记录 timeline
    self.timeline = timeline
}.catch {
    // 整个方法链的错误都会在这处理
}
```
可以看出，多次异步请求通过 `Promise` 的方法调用，看起来就像进行同步操作一样，顺序和逻辑也更加清晰了。使用 `then` 方 法可以让异步操作一个接着一个地按顺序进行。如果异步操作 `fetchUserInfo` 失败，会返回一个状态是 `rejected` 的 `Promise` 对 象，返回的这个 `Promise`对象会跳过后面所有的`then` 方法直接执行 `catch` 方法。这就和事件总线中发布事件触发后，**订阅事件会一个接一个执行是一样的**。

除了 `then` 和 `catch` 方法以外，`PromiseKit` 还有一些好用的方法。
* 比如 `always`方法。使用了 `always` 方法以后， `Promise` 对象每次在执行方法时，都会执行一次 `always` 方法。
* 再比如`when` 方法。这个方法的使用场景就是，指定多个异步操作，等这些操作都执行完成后就会执行 `when` 方法。`when`方法类似 `GCD` 里面的 `Dispatch Group`，虽然实现的功能一样，但是代码简单了很多，使用起来也更加方便。

`PromiseKit` 还为苹果的 `API` 提供了扩展。这些扩展需要单独集成，你可以在[PromiseKit 组织⻚面](https://github.com/PromiseKit)获取。目前大部分常用的`API`
都有扩展，比如 `UIKit`、`Foundation`、`CoreLocation`、`QuartzCore`、`CloudKit` 等等，甚至还支持了第三方的框架 `Alamofire`。

### Flexbox布局比自动布局好在哪里
 `React Native`、`Weex` 和 `Texture`(`AsyncDisplayKit`) 这些知名布局库采用的就是`Flexbox`布局思路。不可小觑的是，苹果公司官方的`UIStackView`，也是采用`Flexbox`思路来实现布局的。

 目前来看，`iOS` 系统提供的布局方式有两种:
 * `Frame`
 * `Auto Layout`

 通过 [Masonry](https://github.com/SnapKit/Masonry)和 [SnapKit](https://github.com/SnapKit/SnapKit)这些第三方库，自动布局的易用性也有了很大提升。而且`iOS 12` 以后，苹果公司也已经解决了自动布局在性能方面的问题;

**我们为什么还要关注其他布局思路呢?**

 **其一**，自动布局思路本身还可以再提高。`Flexbox` 比自动布局提供了更多、更规范的布局方法，布局方式考虑得更全面，使用
 起来也更加方便。同时，苹果公司基于 `Flexbox` 的布局思路，又在自动布局之上封装了一层 `UIStackView`。
 **其二**，针对多个平台的库需要使用更加通用的布局思想。`Flexbox` 在`2009`年被 `W3C` 提出，可以很简单、完整地实现各种⻚面布局，而且还是响应式的，开始被应用于前端领域，目前所有浏览器都已支持。后来通过 `React Native` 和 `Weex` 等框架，它被带入到客户端开发中，同时支持了 `iOS` 和 `Android`。

 * [Flex 布局教程:语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)

 **Texture 如何使用 Flexbox 思路进行布局?**
 `Texture`框架的布局中，`Texture`考虑到布局扩展性，提供了一个基类 `ASLayoutSpec`。这个基类提供了布局的基本能力，使 `Texture` 可以通过它扩展实现多种布局思路，比如 `Wrapper`、`Inset`、`Overlay`、`Ratio`、`Relative`、`Absolute` 等布局思路，也可以继承 `ASLayoutSpec` 来自定义你的布局算法。
`ASLayoutSpec`的子类，及其具体的功能如下:
```
ASAbsoluteLayoutSpec // 绝对布局
ASBackgroundLayoutSpec // 背景布局
ASInsetLayoutSpec // 边距布局
ASOverlayLayoutSpec // 覆盖布局
ASRatioLayoutSpec // 比例布局
ASRelativeLayoutSpec // 顶点布局
ASCenterLayoutSpec // 居中布局
ASStackLayoutSpec // 盒子布局
ASWrapperLayoutSpec // 填充布局
ASCornerLayoutSpec // ⻆标布局
```
接下来，我们一起看看`ASLayoutSpec`的子类中，应用最广泛的`ASStackLayoutSpec`。它和 iOS 中自带的 `UIStackView` 类 似，布局思路参照了 `Flexbox`，比如 `horizontalAlignment`、`alignItems`、`flexWrap` 等属性很容易和 `Flexbox` 对应上。
下面示例是一段官方的 `ASStackLayoutSpec` 示例代码。`ASStackLayoutSpec` 布局思路和 `Flexbox`是一样的，所以我们通过示 例可以了解，如何通过 `Texture` 使用 `Flexbox` 布局思路开发界面:
```
- (ASLayoutSpec *)layoutSpecThatFits:(ASSizeRange)constraint {
		// 创建一个纵轴方向的 ASStackLayoutSpec 视图容器 vStack ASStackLayoutSpec *vStack = [[ASStackLayoutSpec alloc] init]; // 设置两个子节点，第一个节点是标题，第二个正文内容
		[vStack setChildren:@[titleNode, bodyNode];
		// 创建一个横轴方向的 ASStackLayoutSpec 视图容器 hstack
		ASStackLayoutSpec *hstack = [[ASStackLayoutSpec alloc] init];
		hStack.direction = ASStackLayoutDirectionHorizontal;
		hStack.spacing = 5.0; // 设置节点间距为5

		// 在 hStack 里添加 imageNode 和 vStack 节点
		[hStack setChildren:@[imageNode, vStack]];

		// 创建一个 ASInsetLayoutSpec 容器，设置四周边距为5，将 hStack 作为其子节点
		ASInsetLayoutSpec *insetSpec = [ASInsetLayoutSpec insetLayoutSpecWithInsets:UIEdgeInsetsMake(5, 5, 5, 5) child:headerStackSpec];
    return insetSpec;
}
```
上面的视图效果如下:
![](./resources/架构_Flexbox_texture.png)
除了 `Texture` 用到了 `Flexbox` 的布局思路，`React Native` 和 `Weex` 也用到了这个布局思路。这两个框架对 `Flexbox` 算法的实 现，是一个叫作[Yoga](https://github.com/facebook/yoga) 的 C++ 库。
除了 `React Native` 和 `Weex` 之外，`Yoga` 还为很多其他开源框架提供支持，比如 [Litho](https://fblitho.com/)、[ComponentKit](https://componentkit.org/) 等。 为了能够用于各个平台，`Yoga`是由 `C/C++`` 语言编写的，依赖少，编译后的二进制文件也小，可以被方便地集成到 `Android` 和`iOS` 上。

随着新硬件的不断推出，比如手表和折叠屏手机，你可能还需要掌握更多的布局算法，以不变应万变。比如说，除了 `Flexbox` 思路的布局 `ASStackLayoutSpec`以外，`Texture`中还有 `Wrapper`、`Inset`、`Overlay`、`Ratio`、`Relative`、`Absolute` 等针对不同场景的布局思路，同时还支持自定义布局算法。

**Flexbox 算法**
`Flexbox` 算法的主要思想是，让 `flex`容器能够改变其`flex`项目的宽高和顺序，以填充可用空间，`flex`容器可以通过扩大项目来填
充可用空间，或者缩小项目以防止其超出其可用空间。

**首先**，创建一组匿名的 `flex` 项目，按照这组匿名 `flex`项目设置的排列规则对其进行排列。
* 第一步，确定 `flex`项目的 `main space` 和 `cross space`，如果 `flex`容器定义了大小就直接使用定义的大小;否则， 从 `flex`容器的可用空间里减去 `margin`、`border`、`padding`。
* 第二步，确定每个项目的 `flex base` 大小和假设的大小，其中假设的大小是项目依据它最小和最大的大小属性来确定的。 `flex` 容器的大小，由它的大小属性来确定。

**接着**，将 `flex`项目收集到 `flex lines` 中。

**最后**，进行 `Main-Axis` 对⻬和 `Cross-Axis` 对⻬。

* `Main-Axis` 对⻬就是分配剩余空间。对于每个 `flex line`，如果有剩余空间， `margin` 设置为 `auto` 的话，就平均分配剩余空间。
* `Cross-Axis` 对⻬，先要解决自动 `margin`，然后沿 `cross-axis` 对⻬所有 `flex items`;随后确定 `flex container` 使用的 `cross` 大小;最后对⻬所有 `flex lines`。

`flexbox` 的算法简而言之就是:首先依据 `View` 的 `margin`、`padding`、`border` 确定出横纵大小，接下来确定排列，根据 `View` 的大小确定 `Subviews` 的行内容，确定出行中每个 `Subview` 的大小，最终确定出 `Subview` 的位置。

### 怎么应对各种富文本表现需求?
**一个 Web ⻚面预加载库 [STMURLCache](https://github.com/ming1016/GCDFetchFeed/blob/master/GCDFetchFeed/GCDFetchFeed/STMURLCache.m)来预缓存 HTML 里的图片**

在⻓列表这种场景下，如果不用 `HTML` 来描述富文本的话，想要使用原生 `iOS` 代码来描述富文本的话，你还可以使用苹果官方的`TextKit`和`YYText`来展示。

其中，`YYText` 不仅兼容 `UILabel` 和 `UITextView`，在异步文字布局和渲染上的性能也非常好。

**YYText**
`YYText` 对于富文本的图文混排使用的是自定义的 `NSMutableAttributedString` 分类，自定义分类不光简化了 `NSMutableAttributedString`，还增加了功能，除了图片外，可以嵌入 `UIView` 和 `CALayer`。

`UIWebView` 展示的是使用 `HTML` 描述的富文本。`HTML` 是描述富文本最简单和最常用的方式，相对于 `YYText` 或 `TextKit` 那样 描述富文本的方式来说，更加简洁和标准。不过，UIWebView 的缺点也比较明显，同时创建多个 `UIWebView` 实例，对于内存的占用会非常大。
所以，如果是列表展示富文本建议使用 `TextKit` 或者 `YYText`，其他情况可以选择使用 `UIWebView` 来展示富文本。
`WKWebView` 思路类似，使用`WKURLSchemeHandler`就行.

### 代码规范
统一的编码规范，能有限的避免团队成员由于代码风格不一致而导致的相互认同感缺失的问题。

好的代码规范，需要从如下八个方面进行约束：常量、变量、属性、条件语句、循环语句、函数、类、分类;
#### 常量
在常量的使用上，建议尽量使用类型常量，而不是宏定义。比如定义一个字符串常量，可以写成：
```
static NSString * const kStringName = @"kStringName";
```
#### 变量
对于变量来说，我认为好的编码习惯是：
* 变量名应该可以明确体现出功能，最好再加上类型做后缀。这样也就明确了每个变量都是做什么的，而不是把一个变量当作不同的值用在不同的地方。
* 在使用之前，需要先对变量做初始化，并且初始化的地方离使用它的地方越近越好。
* 不要滥用全局变量，尽量少用它来传递值，通过参数传值可以减少功能模块间的耦合。

#### 属性
`Objective-C` 里的属性，要尽量通过 `get` 方法来进行懒加载，以避免无用的内存占用和多余的计算。
`Swift` 的计算属性如果是只读，可以省掉 `get` 子句，实例代码如下：
```
var areaDouble : Double {
    return long * width
}
```
#### 条件语句
在条件语句中，需要考虑到条件语句中可能涉及到的所有分支条件，对于每个分支条件都需要考虑到，并进行处理，减少或不使用默认处理。特别是 `Switch` 处理枚举时，不要有 `default` 分支。

另外，条件语句的嵌套分支不宜过多，可以充分利用 `Swift` 中的 `guard` 语法
例如这段实例代码
```
if let userName = login.userNameOK {
    if let password = login.passwordOK {
        // 登录处理
        ...
    } else {
        fatalError("login wrong")
    }
} else {
    fatalError("login wrong")
}
```
上面这段代码表示的是，当用户名和密码都没有问题时再进行登录处理，那么我们可以使用 `guard` 语法
```
guard
    let userName = login.userNameOK,
    let password = login.passwordOK,
else {
    fatalError("login wrong")
}
// 登录处理
...
```
#### 循环语句
在循环语句中，我们应该尽量少地使用 `continue` 和 `break`，同样可以使用 `guard` 语法来解决这个问题。解决方法是：所有需要 `continue` 和 `break` 的地方统一使用 `guard` 语法去处理，将所有的异常放到一处。这样的好处是在维护的时候方便阅读，使得代码更加易读和易于理解。

#### 函数
对于函数来说，体积不宜过大，最好控制在百行代码以内。如果函数内部逻辑过多，我们可以将复杂逻辑分解成多个小逻辑。并将每个小逻辑提取出来作为一个单独的函数，每个函数处理最小单位的逻辑，然后一层一层往上组合。
这样我们可以通过函数名明确那段逻辑处理的目的，提高代码的可读性。
拆分成多个逻辑简单的函数之后，我们需要对函数的入参进行验证，同样 `guard` 语法同样适用于检查入参。
```
func saveRSS(rss: RSS?, store: Store?) {
    guard let rss = rss else {
        return
    }
    guard let store = store else {
        return
    }

    // 保存 RSS
    return
}
```
另外，函数内部尽量避免使用全局变量来传递数据，使用参数或者局部变量传递数据能够减少函数对外部的依赖，减少耦合，提高函数的独立性，提高单元测试的准确性。

#### 类
在 `Objective-C` 中，类的头文件应该尽可能少的引入其他类的头文件，可以通过 `class` 关键字进行声明，然后在实现文件里引入需要的其他类的头文件。
对于继承和遵循协议的情况，无法避免移入其他类的头文件，所以在代码设计时还是要尽量减少继承，特别是继承关系太多时不利于代码的维护和修改，比如说修改父类时还需要考虑对所有子类的影响，如果评估不全，影响就难以控制.

#### 分类
在写分类时，分类里增加的方法名要尽量加上前缀，而如果是系统自带类的分类的话，方法名就一定要加上前缀，来避免方法名重复的问题。
分类适合多人负责同一个类时，根据不同分类来进行各自不同功能代码的维护。

**Code Review**

* swift: [SwiftLint](https://github.com/realm/SwiftLint)
* OC:    [OCLint](http://oclint.org/)


* [使用 OCLint 自定义 MVVM 规则](http://yulingtianxia.com/blog/2019/01/27/MVVM-Rules-for-OCLint/)
