# 底层原理篇
本篇打算以边说概念边解问题的方式深入探讨iOS底层一些逻辑问题,有任何问题欢迎[issue](https://github.com/binzi56/iOSSmallKnowledgePool/issues);

### `@autoreleasepool`与`autorelease`
在开发中经常用`@autoreleasepool`来解决`autorelease`产生的内存问题;
举个🌰:
```
for (NSInteger i = 0; i < 10000000; i++) {
    @autoreleasepool {
        NSString *tempStr = [NSString stringWithFormat:@"临时变量"];
    }
}
```

简述
目前区分是否使用了`autorelease`按以下规律:
> 1. 使用alloc/new/copy/mutableCopy/init 创建临时对象直接返回被retain对象，不会进入autoreleasepool中;(具体看[ARC规定](https://clang.llvm.org/docs/AutomaticReferenceCounting.html#precise-lifetime-semantics), 实际使用上常见于一些对象的构造方法即类方法)
> 2. 使用其它方法创建的临时对象则会自动将返回的对象注册到池子中(注意:这里是自己不持有的对象);

再附一个`NSAutoreleasepool`的生命周期以供观赏:
![NSAutoreleasepool的生命周期](https://upload-images.jianshu.io/upload_images/1893416-68279ed8c41752b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

Q1:`autorelease`因何存在?
在OC的内存管理机制中有一条规律是：谁申请，谁释放;
那么如果需要延长生命周期或者某个方法需要返回一个新建对象并在合适的时机来释放,此时就需要`autorelease`来应对这些情况,这样既能确保对象能正确释放，又能返回有效的对象。

Q2:`autorelease`和`@autoreleasepool`内部是如何实现的?
这里用[GNUstep源码](http://www.gnustep.org/resources/downloads.php)来解释;
```
//autorelease
- (id)autorelease
{
    [NSAutoreleasePool addObject:self];
}
```

```
//@autoreleasepool
+ (void)addobject:(id)anObj{
    NSAutoreleasePool *pool = 取得正在使用的NSAutoreleasePool对象;
    if (pool != nil){
        [pool addobject:an0bj];
    }else{
        NSLog ( @"NSAutoreleasePool对象非存在状态下调用autorelease");
    }
}

- (void)addObject:(id)anObj
{
    [pool.array addObject:anObj];
}
```
`autorelease`实例方法的本质就是调用`NSAutoreleasePool`对象的`addObject:`类方法，然后这个对象就被追加到正在使用的`NSAutoreleasePool`对象中的数组里。
当然这里只是选用GNUstep源码的解释, 实际Apple的实现则更为复杂;

**调用流程**
如果我们手动在代码外面再套一层`autorelease`，它就会被最近的`autoreleasepool`管理，一般是当前线程默认创建的`autoreleasepool`，此`autoreleasepool`的释放时机一般是当前`runloop`循环结束，所以会看到的现象就是内存一直飙升，然后断崖式下降。

其他相关的点:
使用容器的`block`版本的枚举器时，内部会自动添加一个`AutoreleasePool`;
```
[array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
    // 这里被一个局部@autoreleasepool包围着
}];
```

参考:
* [黑幕背后的Autorelease](http://blog.sunnyxx.com/2014/10/15/behind-autorelease/)
* [Revisit iOS Autorelease 之不经意间可能被影响的优化](https://www.sohu.com/a/336220048_208051)


### `Runtime Method Swizzling`原理
`Runtime Method Swizzling` 编程方式，也可以叫作`AOP`(`Aspect-Oriented Programming`，面向切面编程)。
`AOP` 是一种编程范式，也可以说是一种编程思想，使用 `AOP` 可以解决 `OOP`(`Object Oriented Programming`，面向对象编
程)由于切面需求导致单一职责被破坏的问题。通过 `AOP` 可以不侵入 `OOP` 开发，非常方便地插入切面需求功能。

#### 直接使用 Runtime 方法交换开发的⻛险有哪些?
`Runtime` 不光能够进行方法交换，还能够在运行时处理 `Objective-C` 特性相关(比如类、成员函数、继承)的增删改操作。
苹果公司已经开源了`Runtime`，在 `GitHub` 上有[可编译的 Runtime 开源版本](https://github.com/0xxd0/objc4)。
你可以通过于德志 (@halfrost)博客的三篇 Runtime 文章，即[isa和Class](https://halfrost.com/objc_runtime_isa_class/)、[消息发送与转发](https://halfrost.com/objc_runtime_objc_msgsend/)，以及[如何正确使用Runtime](https://halfrost.com/how_to_use_runtime/)，来一边学习一边调试。
直接使用`Runtime`的方式如下:
```
#import "ZBHook.h"
#import <objc/runtime.h>

@implementation ViewHook

+ (void)hookClass:(Class)classObject fromSelector:(SEL)fromSelector toSelector:(SEL)toSelector {
    Class class = classObject;
    // 得到被替换类的实例方法
    Method fromMethod = class_getInstanceMethod(class, fromSelector);
    // 得到替换类的实例方法
    Method toMethod = class_getInstanceMethod(class, toSelector);

    // class_addMethod 返回成功表示被替换的方法没实现，然后会通过 class_addMethod 方法先实现；返回失败则表示被替换方法已存在，可以直接进行 IMP 指针交换
    if(class_addMethod(class, fromSelector, method_getImplementation(toMethod), method_getTypeEncoding(toMethod))) {
      // 进行方法的替换
        class_replaceMethod(class, toSelector, method_getImplementation(fromMethod), method_getTypeEncoding(fromMethod));
    } else {
      // 交换 IMP 指针
        method_exchangeImplementations(fromMethod, toMethod);
    }

}

@end

```
[RSSwizzle](https://github.com/rabovik/RSSwizzle/)库里指出了四个典型的直接使用 `Runtime` 方法进行方法交换的⻛险。整理如下:
* 第一个⻛险是，需要在 `+load` 方法中进行方法交换。因为如果在其他时候进行方法交换，难以保证另外一个线程中不会同时调用被交换的方法，从而导致程序不能按预期执行。
* 第二个⻛险是，被交换的方法必须是当前类的方法，不能是父类的方法，直接把父类的实现拷⻉过来不会起作用。父类的方法必须在调用的时候使用，而不是方法交换时使用。
* 第三个⻛险是，交换的方法如果依赖了 `cmd`，那么交换后，如果 `cmd` 发生了变化，就会出现各种奇怪问题，而且这些问题还很难排查。特别是交换了系统方法，你无法保证系统方法内部是否依赖了 `cmd`。
* 第四个⻛险是，方法交换命名冲突。如果出现冲突，可能会导致方法交换失败。
