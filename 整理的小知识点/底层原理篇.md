# 底层原理篇
本篇打算以问题方式深入探讨iOS底层一些逻辑问题,有任何问题欢迎[issue](https://github.com/binzi56/iOSSmallKnowledgePool/issues);

### `@autoreleasepool`与`autorelease`
在开发中经常用`@autoreleasepool`来解决`autorelease`产生的内存问题;
举个🌰:
```
for (NSInteger i = 0; i < 10000000; i++) {
    @autoreleasepool {
        NSString *tempStr = [NSString stringWithFormat:@"临时变量"];
    }
}
```

简述
目前区分是否使用了`autorelease`按如下规律:
> 1. 使用alloc/new/copy/mutableCopy/init 创建临时对象直接返回被retain对象，不会进入autoreleasepool中;(具体看[ARC规定](https://clang.llvm.org/docs/AutomaticReferenceCounting.html#precise-lifetime-semantics), 实际使用上常见于一些对象的构造方法即类方法)
> 2. 使用其它方法创建的临时对象则会自动将返回的对象注册到池子中(注意:这里是自己不持有的对象);

再附一个NSAutoreleasepool的生命周期以供观赏:
![NSAutoreleasepool的生命周期](https://upload-images.jianshu.io/upload_images/1893416-68279ed8c41752b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

Q1:`autorelease`因何存在?
在OC的内存管理机制中有一条规律是：谁申请，谁释放;
那么如果需要延长生命周期或者某个方法需要返回一个新建对象并在合适的时机来释放,此时就需要`autorelease`来应对这些情况,这样既能确保对象能正确释放，又能返回有效的对象。

Q2:
